### http和https
- http: 超文本传输协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
- https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，HTTP下加入SSL层(SSL协议)，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。  
  https协议的主要作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

#### 区别
1. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。  
2. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  
3. https协议需要ca证书，费用较高。  
4. 使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

#### https工作原理
1. 客户端点击url向网站发送连接请求，要求建立ssl连接
2. 服务端接收到客户端的请求，将其证书（包含公钥）发送给客户端
3. 客户端与服务端协商ssl链接的安全等级，协商一致后建立ssl链接
4. 客户端创建会话密钥，通过服务端的公钥对会话密钥进行加密后传送给网站
5. 网站通过自己的私钥对会话密钥进行解密
6. 服务器通过会话密钥加密客户端和服务端的会话

#### Http请求中的keep-alive有了解吗
在http早期，每个http请求都要求打开一个tcp socket连接，并且使用一次之后就断开这个tcp连接。
使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高http服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。
但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。

### 证书验证
浏览器使用内置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信任的颁证机构签发的，这个网站就是安全可靠的;如果该SSL证书不是根服务器签发的，浏览器就会自动检查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证 书也是可信的。

### xss 和csrf
#### xss
  跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。   
  为cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤
#### csrf
  CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：
       攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。
  使用验证码，检查https头部的refer，使用token

### ssl握手过程
1. 客户端向服务端发出加密通信的请求。这被叫做clientHello请求，
    - 包括支持的协议版本，一个随机数用于等会生成会话密钥，支持的加密方法，支持的压缩方法
2. 回应，serverhello，
    - 确认加密通信协议的版本，一个随机数用于稍后生成会话密钥，确定加密方法，服务器的证书
3. 客户端验证服务端证书是否为可信机构颁步，如果不可信会给访问者一个警告有起决定是否继续通信，
    - 返回一个随机数用于公钥加密，编码改变通知（之后的信息都用双方商定的加密方法和密钥发生），客户端握手结束的通知
4. 服务端收到客户端的第三个随机数后，计算生成本次会话用的“会话密钥”，然后向客户端发送下面信息：
    - 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

### 为什么ssl证书有过期时间
最重要的原因在于吊销。当网站丢失了私钥后，应该向证书颁发机构（ca）申请将其证书放入吊销列表。因如果证书永久有效，吊销列表越来越大，会给浏览器和ca机构增加很大的流量压力。而如果有过期时间，那么ca可以剔除过期的网站，浏览器也不信任过期的证书。

#### 对称加密算法
发送方和接收方持有同一把密钥，发送消息和接收消息都使用该密钥。相比非对称加密算法，该算法加密和解密的速度都更快，但由于双方都需要事先直到密钥，因此在传输过程中更容易被捕获，安全性不如非对称。  
#### 非对称加密算法
接收方生成一个公钥和一个私钥，将公钥发送给发送方。发送方通过该公钥对会话进行加密然后发送到接收方，接收方通过私钥进行解密。发送过程中就算被窃取数据，没有服务端的私钥也难以对信息进行解密，因而安全性较高。

#### http2.0
1. 多路复用。建立一个tcp连接，一个连接上有任意多个流，报文消息分割为一个帧或多个帧在字节流里面并发传输，值得注意的是同一报文的若干帧必须在同一字节流上进行传播。等待报文帧传输完成后再进行消息重组。
2. 二进制分帧。将传输的报文划分为首部和消息负载两个帧，并采用二进制编码。
3. 首部压缩：客户端与服务端维护一份相同的静态字典，里面保存了常用请求头的名称和值，对于字典中只有名称没有值的首部，在传输时需要先索引其值在用哈夫曼编码减少体积，客户端和服务端还会维护一个动态字典用于存放请求用到的头部，后续传播就可以只传索引，
4. 服务器推送：服务端可以主动向客户端推送资源。
    [more](https://juejin.im/post/5c0ce870f265da61171c8c66)

#### 长短连接和长短轮询
- 短连接

所谓短连接，即连接只保持在数据传输过程，请求发起，请求建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。

- 长连接

长连接便是在连接发起后，在请求关闭连接前客户端与服务器都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。

- 短轮询

短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。

- 长轮询

长轮询是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。

- 长短连接和长短轮询的区别  

决定方式。一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务器端的处理方式来决定的，与客户端没有关系。
实现方式。连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。

#### http请求头
1. Accept : 可接受的Content-type
2. Accept-Encoding
3. Accept-Language
4. referer : 请求文件的网址，请求时会携带
5. orgin
6. 缓存的那几个参数
    [more](https://juejin.im/post/5c17d3cd5188250d9e604628)

#### WebSocket是什么原理，用了什么设计模式？
1. 建立在 TCP 协议之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
7. 服务端推送
```javascript
// 只需要new一下就可以创建一个websocket的实例
// 我们要去连接ws协议
// 这里对应的端口就是服务端设置的端口号9999
let ws = new WebSocket('ws://localhost:9999');

// onopen是客户端与服务端建立连接后触发
ws.onopen = function() {
    ws.send('哎呦，不错哦');
};

// onmessage是当服务端给客户端发来消息的时候触发
ws.onmessage = function(res) {
    console.log(res);   // 打印的是MessageEvent对象
    // 真正的消息数据是 res.data
    console.log(res.data);
};
//服务端
// 开始创建一个websocket服务
const Server = require('ws').Server;
// 这里是设置服务器的端口号，和上面的3000端口不用一致
const ws = new Server({ port: 9999 });

// 监听服务端和客户端的连接情况
ws.on('connection', function(socket) {
    // 监听客户端发来的消息
    socket.on('message', function(msg) {
        console.log(msg);   // 这个就是客户端发来的消息
        // 来而不往非礼也，服务端也可以发消息给客户端
        socket.send(`这里是服务端对你说的话： ${msg}`);
    });
});

```

#### 防刷接口
- 总调用次数受限制。这个一般是在后端做限制，单位时间内最多可调用次数。
- 同一客户端次数限制。这个前端的一般使用是给接口调用加锁，在返回结果或者一定时间之后解锁。
- 请求头refer
- 二次验证

#### 状态码
- 301重定向和302临时重定向
- 301利于seo，因为seo会将旧地址的外部连接转移到新地址下，不会影响网站的排名。302除Google外会将外部连接向多个域名分摊，削弱主站的连接数量，降低主站排名
```
1XX: 通知
100 Continue 客户端应重新发请求
101 Switching Protocols 改用协议 http换到https或者http1.1换到2.0之类

2XX：成功
200 OK 操作成功
201 Created按照客户端请求创建了一个新资源
204 No Content 请求成功，但是报文不含实体的主体部分

3XX：重定向
301 Moved Permanently永久性重定向，资源已经被分配到了新的URL
302 Found 临时重定向，资源临时分配了URL 实际上发部分客户端把它当成303处理
303 See Other 表示资源存在另一个URL。应用Get获取资源
304 Not Modified 允许访问资源，但实体主体为空（客户端已经有此数据，不需要再次发送）

4XX：客户端错误
400 Bad Request 请求报文语法错误
401 Unauthorized 发送的请求需要通过验证，客户端试图对一个受保护的资源操作但没有认证证书
403 Forbidden 请求资源存在但被拒绝，常用于一个资源只允许在特定时间段内访问（如果不想透露可以谎报404）
404 Not Found 找不到请求的资源
405 Method Not Allowed 不支持的请求方法，比如只支持Get，但是收到了Post请求
5XX：服务端错误
500 Internal Server Error 执行请求时发生错误（处理异常）
503 Service Unavailable 服务器暂时处于超负荷或者维护中
```

### tcp详解
#### OSI七层模型
1. 物理层：底层数据传输，如网线；网卡标准。 
2. 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。
3. 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。
4. 传输层：端到端传输数据的基本功能；如 TCP、UDP。
5. 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
6. 标识层：数据格式标识，基本压缩加密功能。
7. 应用层：各种应用软件，包括 Web 应用。
- tcp应用
    1. 网络访问层：ARP、RARP
    2. 互联网层：ICMP、IP
    3. 传输层：TCP、UDP
    4. 应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS
#### ARP,RARP,ICMP
ARP是ip获取MAC地址的协议（先从自身缓存找，没有的话向网络广播），RARP与ARP相反，ip包数据发送错误时，ICMP协议会将错误信息封包发给主机
#### 三次握手
1. 客户端发送一个syn=1连接请求和一个序列号seq=x，然后客户端进入syn_send状态，等待服务器的确认
2. 服务器收到客户端的syn请求，需要对syn进行确认于是将ack=x+1，然后将序列号seq=y；最后将上述信息放到一个报文段中发送给客户端，服务器进入syn_receive状态
3. 客户端收到服务端的确认信息，ack=y+1，seq=z，向服务端发送ack确认报文。该报文发送完毕后连接建立完成。

#### 为什么要三次握手
主要是为了防止已经失效的请求报文段突然又传送到了服务端造成错误。举个例子，客户端向服务端发送的连接请求报文因网络原因超时，延期很久后到达服务端。服务端收到该连接请求认为是一次新的连接就像客户端发送连接确认请求，但因为该连接报文早已失效，客户端并不会响应服务端的确认信息。不过没有三次握手，服务端会认为连接已经完成，一直等待客户端发送数据，这样服务端的很多资源就浪费了。

#### SYN洪泛攻击：  
- SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。  
- 防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。

#### 四次挥手
1. 客户端发送一个fin=1连接关闭的请求，序号seq=u，客户端的进入fin_wait_1状态  
2. 服务端收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），客户端进入fin_wait_2状态  
3. 服务端向客户端发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态（FIN=1，ACK=1，序号seq=w，确认号ack=u+1）  
4. 客户端收到服务端的fin报文，向客户端发送ack报文然后进入time_wait状态。服务端收到报文后关闭连接。客户端等待两个msl时间后关闭连接（ACK=1，seq=u+1，ack=w+1）

#### 为什么四次挥手
因为tcp是全双工模式，当主机1发送fin报文表示主机1没有数据要发送了，主机2收到该报文发送一个ack确认报文表示我知道主机没有要发送的数据了，但主机1还可以接收报文，主机2发送一个fin到主机1，主机1收到后表示我知道主机2也没有数据要发送了。然后双方再愉快的分手

#### 为什么等待2msl
1. 保证tcp的全双工连接能正常关闭。如果客户端直接关闭，那么ack报文可能因为网络问题导致服务端没有收到客户端的ack确认请求。那么服务端会重新发送fin报文但此时客户端已经关闭该连接因此找不到与服务端对应的连接。
2. 保证此次连接的数据段从网络中消失。如果客户端直接关闭连接，然后马上建立下一次连接，那么有可能新老连接使用的是同一个端口，旧连接因网络原因滞留在网络中的某些数据就会在新连接建立后到达服务端，这样新老连接的数据教会发生混淆
3. msl表示报文最大生存时间，2msl表示发送接收一个来回报文的最大生存时间

### TCP协议如何来保证数据的顺序性

#### 流量控制

- 控制发送方的发送速度，让接收方来得及接收而不至于数据丢失。  
- 使用滑动窗口机制，a向b发数据，建立连接时b告诉a我的接收窗口rwnd=n，因此发送窗口的字节量不能大于该窗口。当报文某一字段丢失b会向a发送一个ack报文，Ack=1，ack=上次接收到的序列号队尾+1，新的rwnd；当接收窗口满了也会发送ack报文，当数据全部接受会发送一个ack，rwnd=0

#### 拥塞控制
发送方维持一个拥塞窗口cwnd，该窗口的大小随网络拥塞程度动态变化
1. 慢开始算法：建立连接时将cwnd设置为最大报文段mss的数值，试探性发送，收到确认信息后逐倍加大cwnd的大小。cwnd有一个门限值，当cwnd < 门限则使用慢开始算法，大于使用拥塞避免，=则两者即可。
2. 拥塞避免：与慢开算法相比，cwnd不再是逐倍数放大，而是每次加1，让其线性缓慢增长
3. 快重传：要求接收方收到一个失序报文后立即发出确认报文而不是等到需要自己发送数据时在携带该信息。当收到连续3个重复的确认信息时发送方立即重传该缺失报文
4. 快恢复：当发送方连续收到三个重复确认信息后，将慢开始门限减半，然后不执行慢开始而是使用拥塞避免算法使cwnd窗口线性增大

### tcp协议怎么保证数据完整性

#### 校验与重传策略是怎样的  

- 校验策略是说每一个tcp数据都会带着数据的校验和，服务端接收到tcp数据首先会验证校验和，如果验证不对，服务端将丢弃这个tcp数据和不确认收到此报文段（希望发端超时并重发）。重传策略是说，每一次数据发送是客户端都会同时起一个定时器，如果在指定时间内没有接收到服务端的确认，就把数据再发一次。  

#### tcp和udp的区别
1. tcp是面向连接的，udp是无连接的
2. tcp提供可靠交互，报文传输无差错，不丢失，不重复地按序到达，而udp是尽可能地实现交互，即提供不可靠交互
3. tcp是面向字节流，udp面向报文。应用层一次发送给tcp一个数据块，tcp将其视为无结构字节流，tcp中有一个缓存，当应用程序数据块太长tcp会将其划分为更小的块传输。而udp则无论应用层发送多层的报文都会照样直接发送，因此应用层必须选择合适的报文大小，太长ip层需要分片，降低效率；太短，ip太小。
4. tcp支支持1对1双交互，udp支持1对1，1对多的交互
5. tcp首部为20个字节，udp首部只占8字节
6. 文件，邮件用tcp，视频用udp

### 点击url之后的所有流程
1. ip寻址
    浏览器缓存 => 系统缓存 => 路由器缓存 => dns服务器缓存 => dns服务器递归查询 
- 询问根域名，获取顶级域名 .com 的 NS(Name Server) 和 A(Address)，NS为顶级域名的名字，A即NS对应的ip地址
- 询问顶级域名，获取二级域名 .tencnet.com 的NS 和 A
- 询问二级域名，获取三级域名 .cloud.tencent.com 的NS 和 A
- 询问三级域名，获取四级域名 .tlab.cloud.tencent.com 的NS 和 A
- 最后，将tlab.cloud.tencent.com的ip地址返回给用户，并且缓存
- 用户获取到真正的ip地址，并且缓存

2. tcp连接
    见三次握手
3. 发送http请求到服务端
    将请求头，请求方法，请求主体，经过标识层，会话层，传输层，网络层，数据链路层，物理层到达服务器
4. 服务端响应http报文
5. 浏览器解析并渲染响应报文
    浏览器根据报文的html构建DOM树，构建dom树的时候遇见外部js脚本或js代码会转而下载或执行js（没设置defer，async属性的情况下），会造成阻塞现象，所以推荐把script放在body之后。在这之后，解析css，构建CSSOM树后与dom树合并为渲染树。
6. 连接结束

### 前端优化
- 降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。
- 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。
- 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。
- 渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。
  [more](https://csspod.com/frontend-performance-best-practices/)

### 为什么要禁止跨域

跨域会带来很多安全问题，最常见的如xss和csrf攻击。在前后端交互中，cookie一般用于状态控制，常用于存储登录的信息，如果允许跨域，那么别的网站只需要一段脚本就可以获取你的cookie（xss），然后再冒充你的身份去登录网站。简单来说就是你点击某个网站，然后网站被植入脚本向攻击者的站点发送了获取了你信息的请求。

### 跨域

#### document.domain
`xxx.com/a.html,xxx.com/b.html`,设置两页面的domain为xxx.com就可以跨域
#### `window.name`
跨域参数设置为`window.name`,获取参数的窗口将domain设置为发送参数的同源窗口
#### location.hash
a页面嵌套iframe b页面，a通过修改hash传参，b监听url变化，通过location.hash获取参数。  
b页面通过设置一个与a同源的隐藏iframe，通过改变其hash，a监听变化。。
#### jsonp
利用script获取js文件不受同源策略影响的原则
```
function jsonp(req){
    let script = document.createElement('script');
    let url = `${req.url}?callback=${req.query}`
    script.src = url;
    document.getElementsByTagName('head')[0].append(script)
}
```
#### cros
使用ajax请求进行跨域，需要前后端协调一致。
后端需要设置允许的请求头，请求方法，请求来源ip等

#### 跨域请求中，需要设置哪个属性为true,才能携带cookie信息？

withCredentials

### 缓存机制

![image](https://img-blog.csdnimg.cn/20190304103021382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1dGFsX2xqdA==,size_16,color_FFFFFF,t_70)
#### 强缓存
- Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。
- Cache-Control有很多属性，不同的属性代表的意义也不同。
  private：客户端可以缓存
  public：客户端和代理服务器都可以缓存
  max-age=t：缓存内容将在t秒后失效
  no-cache：需要使用协商缓存来验证缓存数据
  no-store：所有内容都不会缓存。
  ![image](http://jiangliuer.vip/download/image/upbuffer.jpg)
#### 协商缓存
- Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。
- if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。
- if-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改
- If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识
- Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识。由content-length(报文头部之外内容的长度)和last-modified构成的十六进制字符串组成。由于last-modified含mtime（文件内容改变时间戳）所以文件etag变了可能文件并没有变化。
  ![image](http://jiangliuer.vip/download/image/lowbuffer.jpg)

#### 你真的懂cookie么
![image](https://user-gold-cdn.xitu.io/2017/10/2/07ecb36c4820a66de90013f303cac8c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
1. name: cookie的名字
2. value: cookie的值
3. domain: cookie绑定的域名
4. path: cookie匹配的web路由
5. max-age: 0 : 失效  time: time秒失效  负数：临时存储，不会生成cookie文件
6. secure为true，cookie只会在https和ssl等安全协议下传输
7. httpOnly为true，禁止js获取cookie的值，有效防止xss攻击

#### cookie 和 session的区别
1. 前者位于客户端，后者位于服务端
2. 前者存储的信息不是很安全，可被别人获取分析，后者信息存储在服务器上，不会被窃取
3. 当同一时间内请求服务器的用户很多时，使用session会比较占用服务器性能，这时可以使用cookie减轻服务器负担，提升性能。
4. cookie存储字符串，session存储对象
5. session不能区分路径，cookie可以设置路径参数
```
session 认证流程：

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，
服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，
如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。
```

[more](https://juejin.im/post/5e055d9ef265da33997a42cc#heading-19)

#### cookie、localStorage和sessionStorage
1. 存储方面：cookie会在每次http请求中携带不管是否需要，后两个只是本地存储。cookie可以设置路径将其限制在某一特定路径下
2. 容量方面：cookie：4k  后两者：5M+
3. 有效期：cookie在过期时间内有效，localStorage一直有效，sessionStorage关窗口和关浏览器后无效
4. 共享性：cookie和localStorage同源共享，sessionStorage不在不同窗口中共享，即使两个窗口是第一个url
    [more](https://juejin.im/post/5e055d9ef265da33997a42cc#heading-19)

#### token
- 组成
    1. uid（用户唯一标识）
    2. time（当前时间的时间戳）
    3. sign（签名，token前几位以哈希算法压缩成的一定长度十六进制字符串）
- 特点
    1. 服务端无状态化、支持在多个服务间共享
    2. 安全,可以防止csrf攻击
    3. 完全由应用管理，可以避开同源策略
- 流程
    1. 登录   
        ![image](https://user-gold-cdn.xitu.io/2018/1/27/161375750d33b4cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    2. 业务请求  
        ![image](https://user-gold-cdn.xitu.io/2018/1/27/161375750d5aa746?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    3. token过期，刷新token  
        ![image](https://user-gold-cdn.xitu.io/2018/1/27/161375750d060f97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### service worker
1. Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能
2. 协议必须是https
3. 注册，监听，查看是否缓存有，没有再请求服务器

#### md5
对用户信息参数进行加密，加密为16位的16进制哈希字符串。客户端用同样的加密方法生成签名进行比对。

#### HTTP request报文结构是怎样的
1. 首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF
2. 首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束
3. 请求头和消息实体之间有一个CRLF分隔
4. 根据实际请求需要可能包含一个消息实体 一个请求报文例子如下：

#### HTTP response报文结构是怎样的
1. 首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF
2. 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部
3. 响应头部和响应实体之间用一个CRLF空行分隔
4. 最后是一个可能的消息实体 响应报文例子如下：

#### option
1. GET，HEAD，POST之外的请求
2. 自定义的请求头
3. application/x-www-form-urlencoded、multipart/form-data、text/plain  
    上述三种方法会触发预请求