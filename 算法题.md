数组

#### 二分查找（熟练）
##### 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
```JavaScript
// 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
// NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
//把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
//10111

1. 原数据为旋转数组，所以分界点前后都是有序的
2. 进行二分查找，注意因为找最小值，high赋值时应该从mid开始取，mid可能是最小值
function minNumberInRotateArray(rotateArray)
{
    if(!rotateArray.length) return 0;
    let left = 0,right = rotateArray.length-1;
    while(left < right){
        let mid = Math.floor((right+left) >> 1);
        if(rotateArray[left] <= rotateArray[right]){
            return rotateArray[left];
        }
        if(rotateArray[left] < rotateArray[mid]){
            left = mid + 1;
        }else if(rotateArray[right] > rotateArray[mid]){
            right = mid;
        }else{
            left++;
        }
    }
}
```
#### 统计一个数字在排序数组中出现的次数。
```JavaScript
二分查找
function GetNumberOfK(data, k)
{
    let low = 0,high = data.length-1;
    let pos,count = 0;
    while(low < high){
        let mid = Math.floor((low+high)>>1);
        if(data[mid] === k){
            pos = mid;
            break;
        }else if(data[mid] < k){
            low = mid + 1;
        }else{
            high = mid-1;
        }
    }
    if(pos !== undefined){
        count++;
        let left = pos,right = pos;
        while(left--){
            if(data[left] === k){
                count++;
            }else{
                break;
            }
        }
        while(right++){
            if(data[right] === k){
                count++;
            }else{
                break;
            }
        }
        return count;
    }else return 0;
}
```

#### hash查找（熟练）
##### 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置,
```JavaScript
// 如果没有则返回 -1（需要区分大小写）.
function FirstNotRepeatingChar(str)
{
    let map = new Map();
    for(let key of str){
        map.has(key) ? map.set(key,map.get(key)+1) : map.set(key,1);
    }
    for(let [key,value] of map){
        if(value === 1) return str.indexOf(key);
    }
    return -1;
}
```

##### 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
```JavaScript
function FindNumsAppearOnce(array)
{
    let map = new Map();
    for(let i = 0;i < array.length;i++){
        map.has(array[i]) ? map.set(array[i],map.get(array[i]) + 1) : map.set(array[i],1);
    }
    let ans = [];
    for(let [index,value] of map){
        if(ans.length > 2) break;
        if(value === 1){
            ans.push(index);
        }
    }
    return ans;
}
```

##### 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。
```javascript
// 请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
function duplicate(numbers, duplication)
{
    let map = new Map();
    for(let i = 0;i < numbers.length;i++){
        map.has(numbers[i]) ? map.set(numbers[i],map.get(numbers[i]) + 1) : map.set(numbers[i],1);
        if(map.get(numbers[i]) > 1){
            duplication[0] = numbers[i];
            return true;
        }
    }
    return false;
}

//解法2
function FindNumsAppearOnce(array)
{
    let n = array[0];
    for(let i = 1;i < array.length;i++){
        n ^= array[i];
    }
    let k = 1,pow = 1;
    while(n > k){
        pow++;
        k = 2 ** pow - 1;
    }
    n = (n-1) ^ k;
    let left,right;
    for(let i = 0;i < array.length;i++){
        if(array[i] & n){

            left = left ? left ^ array[i] : array[i];
        }else{
            right = right ? right ^ array[i] : array[i];
        }
    }
    return [left,right];
}
```

#### 双指针（熟悉）

##### 最短无序连续子数组（熟悉）

```js
//给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
//你找到的子数组应是最短的，请输出它的长度。
1. 先排序
2. 双指针查找排序后与排序前两个边的下标
3. 对于原本排好序的样例需要特判
var findUnsortedSubarray = function(nums) {
    let num = nums.slice(0);
    num.sort((x,y) => x-y);
    let left = 0,right = nums.length-1;
    while(left < nums.length){
        if(num[left] !== nums[left]) break;
        left++;
    }
    while(right > 0){
        if(num[right] !== nums[right]) break;
        right--;
    }
    if(right === 0) return 0;
    return right - left + 1;
};
```

##### 盛最多水的容器（熟悉）

![image](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```js
双指针时刻更新最大值即可
var maxArea = function(height) {
    if(!height.length) return 0;
    let left = 0,right = height.length-1,res = 0;
    while(left < right){
        if(height[left] <= height[right]){
            let cur = height[left] * (right - left);
            res = Math.max(res,cur);
            left++;
        }else{
            let cur = height[right] * (right - left);
            res = Math.max(res,cur);
            right--;
        }
    }
    return res;
};
```



##### 接雨水（熟悉）

![iamge](https://img-blog.csdn.net/20180913083730924?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjMxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```js
function trap(arr){
    if(!arr.length) return 0;
    let left = 0,right = arr.length-1,leftHeight = 0,rightHeight = 0,res = 0;
    while(left < right){
        if(arr[left] < arr[right]){
            leftHeight = Math.max(arr[left],leftHeight);
            res += leftHeight - arr[left];
            left++;
        }else{
            rightHeight = Math.max(arr[right],rightHeight);
            res += rightHeight - arr[right];
            right--;
        }
    }
    return res;
}
```

##### 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。
```JavaScript
// 但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。
// 没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
// 现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
计算连续数平均和查看是否为目标值，大了low++，小了high++
function FindContinuousSequence(sum)
{
    let low = 1,high=2;
    let result = [];
    while(high > low){
        let cur = ((low+high) / 2) * (high-low+1);
        if(cur === sum){
            let list = [];
            for(let i = low;i <= high;i++){
                list.push(i)
            }
            result.push(list);
            high++;
        }else if(cur < sum){
            high++;
        }else{
            low++;
        }
    }
    return result;
}
```
##### 两数之和

```js
var twoSum = function(nums, target) {
    if(!nums.length) return [];
    let num = nums.slice(0);
    nums.sort((x,y) => x-y);
    let l = 0,r = nums.length-1;
    while(l < r){
        if(nums[l] + nums[r] === target) break;
        else if(nums[l] + nums[r] < target){
            l++;
        }else{
            r--;
        }
    }
    l = num.indexOf(nums[l]);
    r = num.indexOf(nums[r]) === l ? num.indexOf(nums[r],l+1) : num.indexOf(nums[r])
    return [l,r];
};
```

##### 三数之和

```js
var threeSum = function(nums) {
    if(nums.length < 3) return [];
    nums.sort((x,y) => x-y);
    let res = [];
    for(let i = 0;i < nums.length;i++){
        //如果第一个数大于1就没必要排了
        if(nums[i] > 0) return res;
        //去重
        if(i && nums[i] === nums[i-1]) continue;
        let left = i+1,right = nums.length-1;
        while(left < right){
            if(nums[left] + nums[right] + nums[i] === 0){
                res.push([nums[i],nums[left],nums[right]]);
                //去重
                while(left < right && nums[left] === nums[left+1]){
                    left++;
                }
                while(left < right && nums[right] === nums[right-1]){
                    right--;
                }
                left++;
                right--;
            }else if(nums[left] + nums[right] + nums[i] > 0){
                right--;
            }else{
                left++;
            }
        }
    }
    return res;
};
```

##### 最接近的三数之和

```js
思路与前面基本一致，但需要两个变量，一个更新答案，一个更新最小差值
var threeSumClosest = function(nums, target) {
    if(!nums.length) return 0;
    let res = Infinity,mins = Infinity;
    nums.sort((x,y) => x-y);
    for(let i = 0;i < nums.length;i++){
        let left = i + 1,right = nums.length-1;
        while(left < right){
            mins = Math.min(Math.abs(nums[i]+nums[left]+nums[right]-target),mins);
            mins === Math.abs(nums[i]+nums[left]+nums[right]-target) 
            && (res = nums[i]+nums[left]+nums[right]);
            if(nums[i]+nums[left]+nums[right] < target){
                left++;
            }else if(nums[i]+nums[left]+nums[right] > target){
                right--;
            }else{
                break;
            }
        }
    }
    return res;
};
```



#### 矩阵（熟悉）

##### 将图像顺时针旋转 90 度。

```js
矩阵top，right两个指针沿外层向内调换行顺序，再矩阵转置。
var rotate = function(matrix) {
    if(!matrix.length) return [];
    let left = 0,right = matrix.length-1;
    while(right-left > 0){
        [matrix[left],matrix[right]] = [matrix[right],matrix[left]];
        left++;
        right--;
    }
    for(let i = 0;i < matrix.length;i++){
        for(let j = i+1;j < matrix[i].length;j++){
            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]];
        }
    }
    return matrix;
};
```

##### 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
```javascript
// 例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
旋转魔方法，每次打印第一列，然后将矩阵逆时针旋转
function rotate(arr){
    if(!arr.length) return [];
    let newArr = [];
    for(let i = 0;i < arr[0].length;i++){
        let temp = [];
        for(let j = 0;j < arr.length;j++){
            temp.push(arr[j][arr[0].length-1-i]);
        }
        newArr.push(temp);
    }
    return newArr;
}
function printMatrix(matrix)
{
    if(!matrix.length) return [];
    let ans = [];
    while(matrix.length){
        for(let i = 0;i < matrix[0].length;i++){
            ans.push(matrix[0][i])
        }
        matrix.splice(0,1);
        matrix = rotate(matrix);
    }
    return ans;
}
```
##### 螺旋矩阵

```js
1. 遇到拐点，改变方向
2. 访问到已经赋值的节点时，回退到上一个节点，并改变方向
var generateMatrix = function(n) {
    x_dire  rows方向; y_dire  clos方向; cur_dire  当前是rows方向还是cols方向
    let rows = n-1,cols = n-1,col = 0,row = 0,iter = 1,x_dire = 1,y_dire = 1,cur_dire = 1,res = [];
    for(let i = 0;i < n;i++) res.push([]);
    while(iter <= n ** 2) {
        if (cur_dire === 1 && res[row][col] === undefined) {
            res[row][col] = iter;
            iter++;
            if (x_dire === 1) {
                if (col < cols) {
                    col++;
                } else {
                    cur_dire = -1;
                    x_dire = -x_dire;
                    if (y_dire === 1) row++;
                    else row--;
                }
            } else {
                if (col > 0) {
                    col--;
                } else {
                    cur_dire = -1;
                    x_dire = -x_dire;
                    if (y_dire === 1) row++;
                    else row--;
                }
            }
        }else if (cur_dire === 1 && res[row][col]) {
            if (y_dire === 1) row++;
            else row--;
            x_dire = -x_dire;
            cur_dire = -1;
            if (x_dire === 1) col++;
            else col--;
        }else if (cur_dire === -1 && res[row][col] === undefined) {
            res[row][col] = iter;
            iter++;
            if (y_dire === 1) {
                if (row < rows) {
                    row++;
                } else {
                    cur_dire = 1;
                    y_dire = -y_dire;
                    if (x_dire === 1) col++;
                    else col--;
                }
            } else {
                if (row >= 0) {
                    row--;
                } else {
                    cur_dire = 1;
                    y_dire = -y_dire;
                    if (x_dire === 1) col++;
                    else col--;
                }
            }
        } else if(cur_dire === -1 && res[row][col]) {
            if (x_dire === 1) col++;
            else col--;
            y_dire = -y_dire;
            cur_dire = 1;
            if (y_dire === 1) row++;
            else row--;
        }
    }
    return res;
};
```

##### 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。

```javascript
//不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
矩阵上下半区的计算
function multiply(array)
{
    if(array.length === 0) return [];
    let b = [1];
    for(let i = 1;i < array.length;i++){
        b[i] = array[i-1] * b[i-1];
    }
    let temp = 1;
    for(let i = array.length-2;i >= 0;i--){
        temp *= array[i+1];
        b[i] *= temp;
    }
    return b;
}
```
##### 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，
```javascript
输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
1. 选取左下角的值作为初始值key
2. 如果目标值大于key，因为是最左边的值（最小），所以col++
3. 如果目标值小于，那么更小的值只可能是上一行，所以row--
function Find(target,array){
    let rows = array.length;
    if(rows <= 0) return false;
    let cols = array[0].length;
    if(cols <= 0) return false;
    let row = rows - 1;
    let col = 0;
    while(row >= 0 && col < cols){
        if(array[row][col] > target){
            row--;
        }else if(array[row][col] < target){
            col++;
        }else{
            return true;
        }
    }
    return false;
}
```

#### 其他

##### 大整数相乘

```js
var multiply = function(num1, num2) {
    const left = '0'.charCodeAt(0);
    // 首先将字符串用 charCodeAt 转换成对应的数字。
    // num1Arr 取较短的数字， num2Arr 取较长的数字，用 num1Arr 去分别乘 num2Arr 速度会提升15ms
    const num1Arr = (num1.length > num2.length ? num2 : num1).split('').map(item => item.charCodeAt(0) - left);
    const num2Arr = (num1.length > num2.length ? num1 : num2).split('').map(item => item.charCodeAt(0) - left);
    let res = [];
    for (let i = num1Arr.length - 1; i > -1; i--) {
        for (let j = num2Arr.length - 1; j > -1; j--) {
            // 数字的相乘的结果转换为数组，并且 reverse，方便计算
            const resArr = (num1Arr[i] * num2Arr[j]).toString().split('');
            resArr.reverse();
            const index = num2Arr.length - 1 - j + num1Arr.length - 1 - i;
            let next = 0, k = 0;
            while (k < resArr.length || next !== 0) {
                // 结果当前位数加上前一位的进位
                let sum = (res[index + k] | 0) + next;
                // 若 k < resArr，即非最后一位进位
                if (k < resArr.length) {
                    sum += +resArr[k];
                }
                res[index + k] = sum % 10;
                // 若 sum 大于10，进位 = 1
                next = sum / 10 >= 1 ? 1: 0;
                k++;
            }
        }
    }
    // 去除结果前的 0
    while (res.length > 1 && res[res.length - 1] === 0) {
        res.pop();
    }
    return res.reverse().join('');
};
```

##### 和为k的子数组（熟悉）

```js
将每个数值作为start求满足k值的个数，之后累加
var subarraySum = function(nums, k) {
    if(!nums.length) return 0;
    let res = 0;
    for(let i = 0;i < nums.length;i++){
        let cur = 0;
        for(let j = i;j < nums.length;j++){
            cur += nums[j];
            if(cur === k) res++;
        }
    }
    return res;
};
```

##### 合并区间

```js
1. 按开始时间排序
2. 比较当前开始时间是否小于等于栈顶结束时间
3. 注意结束时间更晚再合并
var merge = function(intervals) {
    if(!intervals.length) return [];
    intervals.sort((x,y) => x[0]-y[0]),res = [];
    for(let i = 0;i < intervals.length;i++){
        if(i === 0) res.push(intervals[i]);
        else{
            if(intervals[i][0] <= res[res.length-1][1]){
                if(intervals[i][1] > res[res.length-1][1])res[res.length-1][1] = intervals[i][1];
            }else{
                res.push(intervals[i]);
            }
        }
    }
    return res;
};
```

#####  除自身以外数组的乘积（熟悉）

```js
分别找到该数左右两边数的乘积，
然后左右两边相乘
var productExceptSelf = function(nums) {
    if(!nums.length) return [];
    let res = [];
    let k = 1;
    for(let i = 0;i < nums.length;i++){
        res[i] = k;
        k *= nums[i];
    }
    k = 1;
    for(let i = nums.length-1;i >= 0;i--){
        res[i] *= k;
        k *= nums[i];
    } 
    return res;
};
```

##### 找到所有数组中消失的数字（熟悉）

```js
巧妙的使用下标和正负号标记数组，数组中为正的空位即为没出现的数
var findDisappearedNumbers = function(nums) {
    for(let i = 0;i < nums.length;i++){
        //易错点
        nums[Math.abs(nums[i])-1] = nums[Math.abs(nums[i])-1] > 0 
        ? -nums[Math.abs(nums[i])-1] : nums[Math.abs(nums[i])-1];
    }
    let res = [];
    for(let i = 0;i < nums.length;i++){
        if(nums[i] > 0){
            res.push(i+1);
        }
    }
    return res;
};
```

##### 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。（熟悉）

```js
var moveZeroes = function(nums) {
    if(!nums.length) return [];
    for(let i = 0;i < nums.length;i++){
        if(nums[i] === 0){
            nums.push(nums.splice(i,1));
            i--;
        }
    }
    return nums;
};
```

##### 给定整数数组a，实现一个函数，计算出从a中选择多个不相邻元素组成最大的和是多少（熟悉）

```json
1. dp[i] += Max(dp[i-2],dp[i-3]);
var x = [1, 4, 5, 3,1]
var y = [3, 12, 6, 2, 4]

function countMax(arr){
    if(arr.length <= 1) return arr[0];
    if(arr.length === 2) return Math.max(arr[0],arr[1]);
    if(arr.length === 3) return Math.max(arr[0]+arr[2],arr[1]);
    for(let i = 3;i < arr.length;i++){
        arr[i] += Math.max(arr[i-3],arr[i-2]);
    }
    return Math.max(arr[arr.length-1],arr[arr.length-2])
}
console.log(countMax(x)) // 7
console.log(countMax(y)) // 16
```

##### 反转一个含有n个整数的数组，不能使用内置方法（熟悉）

```js
var x = [0, 1, 2, 3];
var y = [1, 2, 3, 4, 1];
function reverse(arr) {
    if(arr.length <= 1) return arr;
    let k = Math.floor(arr.length >> 1);
    let left = 0,right = arr.length - 1;
    while(k--){
        [arr[left],arr[right]] = [arr[right],arr[left]];
        left++;
        right--;
    }
    return arr;
}
//console.log(reverse(x, 4)) // x = [3, 2, 1, 0]
//console.log(reverse(y, 5))// y = [1, 4, 3, 2, 1]
```

##### 将给定数组拆分为两个数组，并使得这两个数组的和最接近（熟悉）

```javascript
const arr = [1,23,544,64,47,56,12,456,32,12];
function beibao(arr){
    arr = arr.sort((x,y) => y-x);
    let arr1 = [],arr2 = [];
    let cur1 = 0,cur2 = 0;
    for(let i = 0;i < arr.length;i++){
        if(cur1 <= cur2){
            arr1.push(arr[i]);
            cur1 += arr[i];
        }else if(cur1 > cur2){
            arr2.push(arr[i]);
            cur2 += arr[i];
        }
    }
    return [cur1,arr1,cur2,arr2];
}
console.log(beibao(arr))
```
##### 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。（熟悉）
```JavaScript
// 例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
1. count初始化为0，count === 0时，res = 当前数，count++
2. 当前数与res相同count++，否则count--
3. 以上两步能够选出出现次数最多的数，接下来判断它是否超过一半即可
function MoreThanHalfNum_Solution(numbers)
{
    let result,count=0;
    for(let i = 0;i < numbers.length;i++){
        if(count === 0){
            result = numbers[i];
            count++;
        }else{
            if(result === numbers[i]){
                count++;
            }else{
                count--;
            }
        }
    }
    let times = numbers.filter(x => x === result).length;
    return times > Math.floor(numbers.length >> 1) ? result : 0;
}
```
#### LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...（熟悉）
```javascript
// 他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！
// “红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,
// 并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。
// 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。
// 为了方便起见,你可以认为大小王是0。
1. 对牌进行排序，计算王牌数量
2. 查看牌序是否连续，再查看是否有王牌
3. 牌序不连续没王牌就gg

function IsContinuous(numbers)
{
    numbers = numbers.sort((x,y) => x-y);
    let joker = numbers.filter(x => x===0).length;
    for(let i = 1;i < numbers.length;i++){
        if(numbers[i]-numbers[i-1] > 1){
            if(joker) joker--;
            else return false;
        }else if(numbers[i] === numbers[i-1]) return false;
    }
    return true;
}
```

##### 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。（熟悉）
```JavaScript
function GetLeastNumbers_Solution(input, k)
{
    // write code here
    if(k > input.length) return [];
    input = input.sort((x,y)=>x-y);
    let ans = [];
    for(let i = 0;i < k;i++){
    ans.push(input[i])
}
    return ans;
}
```

#### 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，（熟悉）
```javascript
// 则打印出这三个数字能排成的最小数字为321323。
// 字符串ab > ba => a > b
function PrintMinNumber(numbers)
{
    if(numbers.length === 0) return [];
    let arr = numbers.toString().split(',');
    arr =  arr.sort((a,b) => {
        return (a+b) - (b+a);
    })
    return parseInt(arr.join(''))
}
```

#### 在数组中的两个数字，如果前面一个数字大于后面的数字。（了解）
```JavaScript
// 则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。
// 并将P对1000000007取模的结果输出。 即输出P%1000000007
归并排序时，当左边序列中的值大于右边序列的值时，则将mid - curRight的值加入逆序对的个数
let count = 0;
function InversePairs(data)
{
    if (data == null || data.length == 0) {
        return 0;
    }
    MergeSort(data,0,data.length-1);
    return count % 1000000007;
}
function MergeSort(arr,left,right){
    if(left >= right) return;
    let mid = Math.floor((right - left)>>1) + left;
    MergeSort(arr,left,mid);
    MergeSort(arr,mid+1,right);
    Merge(arr,left,mid,right);
}

function Merge(arr,left,mid,right) {
    let temp = [],i = 0;
    let p1 = left,p2 = mid + 1;
    while(p1 <= mid && p2 <= right){
        if(arr[p1] <= arr[p2]){
            temp[i++] = arr[p1++];
        }else{
            count += mid - p1 + 1;
            temp[i++] = arr[p2++];
        }
    }
    while(p1 <= mid){
        temp[i++] = arr[p1++];
    }
    while(p2 <= right){
        temp[i++] = arr[p2++];
    }
    for(let i = 0;i < temp.length;i++){
        arr[i+left] = temp[i];
    }
}
```

##### 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，（熟悉）
```JavaScript
// 所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
function reOrderArray(array)
{
    let arr1 = [],arr2 = [];
    for(let value of array){
        if(value % 2) arr1.push(value);
        else arr2.push(value);
    }
    return arr1.concat(arr2);
}
```

### 链表
#### 双指针

##### 删除链表的倒数第n个节点（熟悉）

```js
var removeNthFromEnd = function(head, n) {
    if(!head) return null;
    let fast = head,slow = head,pre = head,p1 = head,len = 0;
    while(p1){
        len++;
        p1 = p1.next;
    }
    //注意头节点删除的情况
    if(len === n) return head.next;
    while(n--){
        fast = fast.next;
    }
    while(fast){
        fast = fast.next;
        pre = slow;
        slow = slow.next;
    }
    pre.next = slow.next;
    return head;
};
```

##### 请判断一个链表是否为回文链表

```js
1. 将前半部分链表反转
2. 判断前后两部分链表是否相等
var isPalindrome = function(head) {
    if(!head) return true;
    let pre = null,temp,fast = head,slow = head;
    while(fast && fast.next){
        temp = slow;
        fast = fast.next.next;
        slow = slow.next;
        temp.next = pre;
        pre = temp;
    }
    if(fast) slow = slow.next;
    while(pre && slow){
        if(pre.val !== slow.val) return false;
        pre = pre.next;
        slow = slow.next;
    }
    return true;
};
```

##### 给定一个链表，判断链表中是否有环（熟悉）

```js
var hasCycle = function(head) {
    if(!head || !head.next || !head.next.next) return false;
    let fast = head.next.next,slow = head.next;
    while(fast !== slow){
        if(fast === null || fast.next === null) return false;
        fast = fast.next.next;
        slow = slow.next;
    }
    return true;
};
```

##### 输入一个链表，输出该链表中倒数第k个结点。（熟悉）
```JavaScript
function FindKthToTail(head, k)
{
    // write code here
    if(head === null || k === 0) return null;
    let fast = head,slow = head;
    while(k--){
        if(fast === null) return null;
        fast = fast.next;
    }
    while(fast){
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```
##### 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。（熟悉）
```JavaScript
//注意与拷贝链表区分
function Merge(pHead1, pHead2)
{
    if(pHead1 === null){
        return pHead2;
    }else if(pHead2 === null){
        return pHead1;
    }
    if(pHead1.val < pHead2.val){
        pHead1.next = Merge(pHead1.next,pHead2);
        return pHead1;
    }else{
        pHead2.next = Merge(pHead2.next,pHead1);
        return pHead2;
    }
}
```

##### 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）（熟悉）
```JavaScript
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    let p1 = pHead1,p2 = pHead2;
    while (p1 !== p2){
        p1 = p1 === null ? pHead2 : p1.next;
        p2 = p2 === null ? pHead1 : p2.next;
    }
    return p1;
}
```

##### 找出环形链表入环位置（熟悉）

```js
var detectCycle = function(head) {
    if(!head || !head.next) return null;
    let fast = head.next.next,slow = head.next,p1 = head;
    while(fast !== null && fast !== slow){
        if(fast.next) fast = fast.next.next;
        else fast = null;
        slow = slow.next;
    }
    if(fast === null) return null;
    else{
        while(p1 !== slow){
            p1 = p1.next;
            slow = slow.next;
        }
        return slow;
    }
};
```



#### 辅助数据结构

##### 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。（熟悉）
```JavaScript
function ListNode(x){
    this.val = x;
    this.next = null;
}
function printListFromTailToHead(head)
{
    let node = head;
    const arr = [];
    while(node){
        arr.unshift(node.val);
        node = node.next;
    }
    return arr;
}
```

##### 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）（熟悉）

```javascript
//返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
1. 在链表中的每一个节点插入一个该节点的复制
2. 为复制节点random赋值
3. 拆分链表
function RandomListNode(x){
    this.label = x;
    this.next = null;
    this.random = null;
}
function Clone(pHead)
{
    if(!pHead) return null;
    let p1 = pHead;
    while(p1){
        let nex = p1.next;
        p1.next = new RandomListNode(p1.label);
        p1.next.next = nex;
        p1 = nex;
    }
    p1 = pHead;
    while(p1){
        p1.next.random = p1.random.next;
        p1 = p1.next.next;
    }
    p1 = pHead.next;
    while(p1.next){
        p1.next = p1.next.next;
        p1 = p1.next;
    }
    return pHead.next;
}
```

##### 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。（熟悉）
```JavaScript
// 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
function deleteDuplication(pHead)
{
    if(pHead === null) return null;
    let map = new Map();
    while(pHead){
        map.has(pHead.val) ? map.set(pHead.val,map.get(pHead.val)+1) : map.set(pHead.val,1);
        pHead = pHead.next;
    }
    let pre = new ListNode();
    for(let [key,value] of map){
        if(value === 1){
            pre.next = new ListNode(key);
            pre = pre.next;
        }
    }
    return pre.next;
}
```

#### 其他

##### 两数相加

```js
//先求出两数，相加后，构造链表
var addTwoNumbers = function(l1, l2) {
    if(!l1) return l2;
    if(!l2) return l1;
    if(!l1 && !l2) return null;
    let count = 1n,num1 = 0n,num2 = 0n;
    while(l1){
        num1 += BigInt(l1.val) * count;
        count = count * 10n;
        l1 = l1.next;
    }
    count = 1n;
    while(l2){
        num2 += BigInt(l2.val) * count;
        count = count * 10n;
        l2 = l2.next;
    }
    let num3 = String(num1 + num2),l3 = new ListNode(Number(num3[num3.length-1])),p1 = l3;
    for(let i = num3.length-2;i >= 0;i--){
        p1.next = new ListNode(Number(num3[i]));;
        p1 = p1.next;
    }
    return l3;
};
```

##### 输入一个链表，反转链表后，输出新链表的表头。
```JavaScript
function ReverseList(pHead)
{
    if(pHead === null || pHead.next === null) return pHead;
    let pre = null,nex = null;
    while(pHead){
        nex = pHead.next;
        pHead.next = pre;
        pre = pHead;
        pHead = nex;
    }
    return pre
}
```

##### 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。（熟悉）
```JavaScript
// 其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。
// 每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,
// 继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。
// 请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
// 如果没有小朋友，请返回-1
function List(val) {
    this.val = val;
    this.next = null;
}
function LastRemaining_Solution(n, m)
{
    if (n < 1 && m < 1) return -1
    let head = new List(0);
    let node = head;
    for(let i = 1;i < n;i++){
        node.next = new List(i);
        node = node.next;
    }
    node.next = head;
    let count = 0;
    while(head !== head.next){
        if(count++ === m - 2){
            head.next = head.next.next;
            count = 0;
        }
        head = head.next;
    }
    return head.val;
}
```

##### 旋转链表指定的长度(熟悉)

```javascript
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
function trans(head,k){
    if(!head || k < 0) return head;
    let tail = head,len = 0;
    while(tail.next){
        len++;
        tail = tail.next;
    }
    //这里需要注意
    let move = len + 1 - k;
    tail.next = head;
    while(move--){
        head = head.next;
    }
    tail = head;
    while(len--){
        tail = tail.next;
    }
    tail.next = null;
    return head;
}
```

### 二叉树

#### 不同的二叉索引树的个数(跳)

```js
卡塔兰数
dp[0] = 1
dp[i] = dp[i-1] * (4 * i + 2) / (i + 2);
var numTrees = function(n) {
    if(!n) return 0;
    let dp = [1];
    for(let i = 1;i < n;i++){
        dp[i] = dp[i-1] * (4 * i + 2) /(i + 2);
    }
    return dp[n-1];
};
```

#### 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。（熟悉）

```js
易错点是直径可能不经过根节点
用max保存最大值，
当每个节点作为根节点时，与max比较进行更新
var diameterOfBinaryTree = function(root) {
    let max = 0;
    function dfs(root){
        if(!root) return 0;
        let l = dfs(root.left);
        let r = dfs(root.right);
        max = Math.max(max,l+r);
        return Math.max(l,r)+1;
    }
    dfs(root);
    return max;
};
```

#### 给定一个二叉树，它的每个结点都存放着一个整数值。

```js
//找出路径和等于给定数值的路径总数。
//路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
//二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
1. 暴力dfs
2. 以每个节点作为开始节点遍历所有路径
function path(root,sum){
    if(!root) return 0;
    let res = 0;
    if(root.val === sum) res++;
    res += path(root.left,sum - root.val);
    res += path(root.right,sum - root.val);
    return res;
}
var pathSum = function(root, sum) {
    if(!root) return 0;
    return path(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);
};
```

#### 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。（熟悉）

```js
//反向中序遍历，依次累加
var convertBST = function(root) {
    let cur = 0;
    re = function(root){
        if(!root) return root;
        re(root.right);
        root.val += cur;
        cur = root.val;
        re(root.left);
        return root;
    }
    return re(root);
};
```

#### 二叉树最近公共祖先（熟悉）

```js
（1）深度优先查找，查到两节点任意一个返回
（2）当两个节点都找到时返回root，否则返回null
var lowestCommonAncestor = function(root, p, q) {
    if(!root) return null;
    if(root === p || root === q) return root;
    let left = lowestCommonAncestor(root.left,p,q);
    let right = lowestCommonAncestor(root.right,p,q);
    if(!left) return right;
    if(!right) return left;
    if(left && right) return root;  
    return null;
};
```

#### 将两颗二叉树合并为一颗（熟悉）

```js
1. bfs遍历
2. 如果两树都有的节点相加 
3. 一树没有二树有，添加二树节点到一树
var mergeTrees = function(t1, t2) {
    //t1,t2都有
    if(t1 && t2){
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left,t2.left);
        t1.right = mergeTrees(t1.right,t2.right);
    }
    //t1或t2独有
    return t1 || t2;
};
```

#### 根据js的依赖关系树tree，输出合理的打包顺序的数组（略）

```js

function resolve(tree){
    let len = tree.require.length,queue = [];
    for(let i = 0;i < len;i++){
        queue.push([]);
    }
    tree = flatten(tree);
    let head = tree.name;
    for(let key in tree){
        let k = Number(key.slice(8,9));
        Object.keys(tree[key]).length && queue[k].push(tree[key])
    }
    let res = [];
    for(let i = queue.length-1;i >= 0;i--){
        for(let j = queue[i].length-1;j >= 0;j--){
            res.indexOf(queue[i][j]) === -1 && res.push(queue[i][j]);
        }
    }
    return res;
}
function flatten(input) {
    let res = {};
    let re = function(obj,key){
        if(obj instanceof Object && !(obj instanceof Array)){
            let empty = true;
            for(let i in obj){
                re(obj[i],key ? `${key}.${i}` : i)
            }
            if(empty && key){
                res[key] = {};
            }
        }else if(obj instanceof Array){
            if(obj.length){
                for(let i = 0;i < obj.length;i++){
                    re(obj[i],key ? `${key}[${i}]` : i)
                }
            }else{
                res[key] = [];
            }
        }else{
            if(obj !== undefined && obj !== null){
                res[key] = obj;
            }
        }
    };
    re(input,'');
    return res;
}
var tree1 = {
    name: 'main.js',
    require: [{
        name: 'A.js'
    }, {
        name: 'B.js'
    }] }

var tree2 = {
    name: 'page.js',
    require: [{
        name: 'A.js',
        require: [{
            name: 'B.js',
            require: [{
                name: 'C.js'
            }]
        }]},
        {
            name: 'D.js',
            require: [{
                name: 'C.js'
            }, {
                name: 'E.js'
            }]
        }] }
resolve(tree1) // ['A.js', 'B.js', 'main.js']
resolve(tree2) // ['C.js', 'E.js', 'D.js', 'B.js', 'A.js', 'page.js']
```

#### 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。（熟悉）
```javascript
// 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
1. 前序遍历第一个节点是根节点
2. 中序遍历由根节点可以划分为左右两颗子树
function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
}

function reConstructBinaryTree(pre, vin)
{
    if(!pre.length || !vin.length) return null;
    let root = new TreeNode(pre[0]);
    let key;
    for(let i = 0;i < vin.length;i++){
        if(vin[i] === pre[0]) {
            key = i;
            break;
        }
    }
    root.left = reConstructBinaryTree(pre.slice(1,key+1),vin.slice(0,key));
    root.right = reConstructBinaryTree(pre.slice(key+1),vin.slice(key+1));
    return root;
}
```

#### 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）（熟悉）

```javascript
function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
}
//判断是否为子结构跟先序遍历类似
function isSubtree(root1,root2) {
    if(!root2) return true;
    if(!root1) return false;
    if(root1.val !== root2.val) return false;
    return isSubtree(root1.left,root2.left) && isSubtree(root1.right,root2.right);
}
//从根节点开始递归判断是否含有子结构
function HasSubtree(pRoot1, pRoot2)
{
    if(!pRoot1 || !pRoot2) return false;
    return (
        isSubtree(pRoot1,pRoot2)
        || HasSubtree(pRoot1.left,pRoot2)
        || HasSubtree(pRoot1.right,pRoot2)
    )
}
```
#### 操作给定的二叉树，将其变换为源二叉树的镜像。（熟悉）
```JavaScript
function Mirror(root)
{
    if(root === null) return root;
    [root.left,root.right] = [root.right,root.left];
    Mirror(root.left);
    Mirror(root.right);
    return root;
}
```

#### 从上往下打印出二叉树的每个节点，同层节点从左至右打印。（熟悉）
```JavaScript
//广搜
1. 将该层次所有节点放入队列
2. 取队首节点放入结果
function bfs(root) {
    if(!root) return [];
    let nodes = [],queue = [root];
    while(queue.length){
        let item = queue.shift();
        nodes.push(item.val);
        item.left && queue.push(item.left);
        item.right && queue.push(item.right);
    }
    return nodes;
}
```
#### 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。（熟悉）
```JavaScript
1. 后序遍历的最后一个节点为根节点
2. 二叉索引树右子树大于根节点，左子树小于根节点，所以可以用根节点将树分为两颗子树
3. 二叉索引树的子树也是二叉索引树，所以分别对子树进行判断，直到遍历到最后一个节点
var verifyPostorder = function(postorder) {
    if(!postorder.length) return true;
    let tail = postorder.pop();
    let key = postorder.length;
    for(let i = 0;i < postorder.length;i++){
        if(postorder[i] > tail){
            key = i;
            break;
        }
    }
    for(let i = key+1;i < postorder.length;i++){
        if(postorder[i] < tail){
            return false;
        }
    }
    return verifyPostorder(postorder.slice(0));
};
```
####  输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径

（易错）

```JavaScript
// 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
1. dfs + 回溯
2. 深度搜索路径，将路径中的每个节点值相加，路径存入缓存，直到遍历到最深处
3. 比较当前值是否为目标值，如果是将缓存的路径加入结果数组，如果不是则回退到上一个节点
function dfs(root,expectNumber,cur,path,result) {
    cur += root.val;
    path.push(root);
    if(cur === expectNumber && root.left === null && root.right === null){
        result.push(path.slice(0));
    }
    root.left && dfs(root.left,expectNumber,cur,path,result);
    root.right && dfs(root.right,expectNumber,cur,path,result);
    //重要
    path.pop();
}
function FindPath(root, expectNumber)
{
    let result = [],path = [],cur = 0;
    if(!root) return result;
    dfs(root,expectNumber,cur,path,result);
    return result;
}
```
#### 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向
```JavaScript
var treeToDoublyList = function(root) {
    if(!root) return null;
    let head = null,tail = null,pre = null;
    function dfs(root){
        if(!root) return null;
        dfs(root.left);
        //第一个节点作为头节点
        if(!pre) head = root;
        //将上一个节点的后继指针指向当前节点
        else pre.right = root;
        //将当前指针的前驱指针指向上一个节点
        root.left = pre;
        //更新上一个节点
        pre = root; 
        //更新尾部节点
        tail = root;
        dfs(root.right);
    }
    dfs(root);
    //首尾连接
    head.left = tail;
    tail.right = head;
    return head;
};
```

#### 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。（熟悉）
```JavaScript
深度遍历，递归到空值取0，每次递归深度++
function TreeDepth(pRoot)
{
    if(pRoot === null) return 0;
    let left = TreeDepth(pRoot.left);
    let right = TreeDepth(pRoot.right);
    return Math.max(left,right) + 1;
}
```
#### 输入一棵二叉树，判断该二叉树是否是平衡二叉树。（熟悉）
```JavaScript
1. 比较两颗子树的高度，两边都取最大深度
2. 查看两颗子树高度差是否相差为1
3. 如果大于1，那么将其标记为-1（表示不是AVL树），然后每次递归时先判断该节点的子树是否时AVL树
function IsBalanced_Solution(pRoot)
{
    return orderTree(pRoot) !== -1;
}
function orderTree(root) {
    if(!root) return 0;
    let left = orderTree(root.left);
    let right = orderTree(root.right);
    if(left === -1 || right === -1 || Math.abs(left-right) > 1) return -1;
    return Math.max(left,right)+1;
}
```
#### 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。（熟悉）
```JavaScript
1. 根据this.next找到父节点
2. 进行中序遍历，将遍历的节点添加到一个数组里
3. 遍历数组寻找该节点
// 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
function TreeLinkNode(x){
    this.val = x;
    this.left = null;
    this.right = null;
    this.next = null;
}
let nodes = [];
function GetNext(pNode)
{
    let root = pNode;
    while(root.next !== null){
        root = root.next;
    }
    inOrder(root);
    for(let i = 0;i < nodes.length;i++){
        if(nodes[i] === pNode){
            return nodes[i+1] === undefined ? null : nodes[i+1];
        }
    }
    return null;
}

function inOrder(root) {
    if(!root) return root;
    inOrder(root.left);
    nodes.push(root);
    inOrder(root.right);
}
```

#### 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。（熟悉）
```JavaScript
判断该二叉树是否与其镜像二叉树相等
function mirrors(root)
{
    if(root === null) return root;
    [root.left,root.right] = [root.right,root.left];
    mirrors(root.left);
    mirrors(root.right);
}

function isSymmetrical(pRoot)
{
    let mirror = JSON.parse(JSON.stringify(pRoot));
    mirrors(mirror);
    if(JSON.stringify(mirror) === JSON.stringify(pRoot)){
        return true;
    }else{
        return false;
    }
}
```

#### 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。（熟悉）
```JavaScript
相比bfs，需要增加两个变量，一个存当前层次的还有多少节点需要打印，一个存储下一层次有多少个节点（每次队列push时进行++）
function Print(pRoot) {
    let nodes = [],queue = [pRoot],path=[];
    let cur = 1,next = 0;
    while(queue.length){
        let node = queue.shift();
        path.push(node.val);
        node.left && queue.push(node.left) && next++;
        node.right && queue.push(node.right) && next++;
        cur--;
        if(!cur){
            nodes.push(path);
            path = [];
            cur = next;
            next = 0;
        }
    }
    return nodes;
}
```
#### 二叉树展开为链表（熟悉）

```js
前序遍历，将右子树放到左子树最右叶子节点的后面，将左子树放到右子树上，左子树置空
var flatten = function(root) {
    function dfs(root){
        if(!root) return;
        dfs(root.left);
        dfs(root.right);
        let pre = root.left;
        if(pre){
            //获取左子树最右叶子节点
            while(pre.right){
                pre = pre.right;
            }
            //将右子树放在左子树最右右子节点后面
            pre.right = root.right;
            //将新构建的左子树放在右子树上
            root.right = root.left;
            //左子树置空
            root.left = null;
        }
    }
    dfs(root);
    return root;
};
```

### 栈和队列

#### 有效的括号（熟悉）

```js
左括号入栈，右括号与栈顶比较是否匹配，匹配弹出栈顶，不匹配return false
查看栈是否为空
var isValid = function(s) {
    if(!s.length) return true;
    let stack = [];
    for(let i = 0;i < s.length;i++){
        if(s[i] === '(' || s[i] === '{' || s[i] === '['){
            stack.unshift(s[i]);
        }else{
            if(s[i] === ')'){
                if(stack[0] === '(') stack.shift();
                else{
                    return false;
                }
            }else if(s[i] === ']'){
                if(stack[0] === '[') stack.shift();
                else{
                    return false;
                }
            }else if(s[i] === '}'){
                if(stack[0] === '{') stack.shift();
                else{
                    return false;
                }
            }
        }
    }
    return stack.length === 0;
};
```

#### 根据身高重建队列（熟悉）

```js
按升高降序，身高相同的按人数升序排列
将队列的每个元素按序插入到索引位置
var reconstructQueue = function(people) {
    if(!people) return [];
    people.sort((x,y)=>{
        return x[0] === y[0] ? x[1]-y[1] : y[0] - x[0];
    });
    let res = [];
    for(let i = 0;i < people.length;i++){
        res.splice(people[i][1],0,people[i]);
    }
    return res;
};
```

#### 中缀表达式转后缀（熟悉）

```javascript
//数字直接添加到result
//栈空，运算符直接入栈
//遇到左括号直接入栈，遇到右括号栈顶元素添加到result中然后弹栈，依次循环直到遇到左括号，然后将左括号弹栈
//遇到运算符，判断运算符与栈顶元素的优先级，将所有优先级大于等于该运算符的栈顶弹栈，然后入栈该运算符
//将栈中剩余的字符添加到result中
function toPoland(str){
    let stack = [],result = '';
    for(let i = 0;i < str.length;i++){
        if(!Object.is(Number(str[i]),NaN)){
            result += str[i];
        }else if(stack.length === 0 && Object.is(Number(str[i]),NaN)){
            result += ' ';
            stack.push(str[i]);
        }else if(str[i] === '('){
            stack.push(str[i])
        }else if(str[i] === ')'){
            result += ' ';
            while(stack[stack.length-1] !== '('){
                result += stack.pop();
            }
            stack.pop();
        }else if(str[i] === '*' || str[i] === '/'){
            while(stack[stack.length-1] === '*' || stack[stack.length-1] === '/'){
                result += ' ' + stack.pop();
            }
            result += ' ';
            stack.push(str[i]);
        }else if(str[i] === '+' || str[i] === '-'){
            while(stack[stack.length-1] === '*' || stack[stack.length-1] === '/' || stack[stack.length-1] === '+' || stack[stack.length-1] === '-'){
                result += ' ' + stack.pop();
            }
            result += ' ';
            stack.push(str[i]);
        }
    }
    while(stack.length){
        result += ' ' + stack.pop();
    }
    return result;
}
```

#### 计算后缀表达式（熟悉）

```javascript
1. 数字入栈
2. 运算符，栈顶作为右操作数，次栈顶作为左操作数
3. 将运算结果入栈
4. 栈最后一个值即为结果
function CalcRPN(str) {
    let stack = [];
    let num = '';
    for(let i = 0;i < str.length;i++){
        if(str[i] === ' '){
            if(num !== '') stack.push(Number(num));
            num = '';
        }else if(!Object.is(Number(str[i]),NaN)){
            num += str[i];
        }else if(str[i] === '+'){
            let right = stack.pop();
            let left = stack.pop();

            stack.push(left + right);
        }else if(str[i] === '-'){
            let right = stack.pop();
            let left = stack.pop();
            stack.push(left - right);
        }else if(str[i] === '*'){
            let right = stack.pop();
            let left = stack.pop();
            stack.push(left * right);
        }else if(str[i] === '/'){
            let right = stack.pop();
            let left = stack.pop();
            stack.push(left / right);
        }
    }
    return stack.pop();
}
```

#### 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。（熟悉）

```javascript
1. 用出入栈进行模拟
2. 进队列全部添加到入栈中
3. 出队列检查出栈是否为空，不为空则将栈顶元素出栈；为空则先将入栈中的所有元素压入出栈
let in_stack = [],out_stack = [];

function push(value) {
    in_stack.push(value);
}

function pop() {
    if(!out_stack.length){
        while(in_stack.length > 0){
            out_stack.push(in_stack.pop())
        }
    }else{
        return out_stack.pop();
    }
}
```

#### 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。（熟悉）
```JavaScript
1. 使用辅助栈存最小值
2. 入栈时检查元素是否为最小值，若是则压入主栈和辅助栈
3. 出栈时检查主栈栈顶元素是否与辅助栈一致，若是则一起弹出
// 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。
let stack1 = [],stack2 = [];
function push(value) {
    if(value <= Math.min(...stack1) || stack1.length === 0){
        stack1.unshift(value);
        stack2.unshift(value);
    }else{
        stack1.unshift(value)
    }
}

function pop() {
    if(stack1.length > 0) {
        if (stack1[0] === stack2[0]) {
            stack1.shift();
            stack2.shift();
        } else {
            stack1.shift();
        }
    }
}

function top() {
    if(stack1.length > 0) {
        return stack1[0];
    }
}

function min() {
    if(stack2.length > 0) {
        return stack2[0];
    }
}
```
#### 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。（熟悉）
```JavaScript
1. 模拟出栈的过程
2. 变量push栈，每次将一个元素压入辅助栈
3. 判断辅助栈是否为空的同时，pop栈的栈顶是否与辅助栈栈顶元素相同，如果都满足则两者出栈
4. 最后判断辅助栈是否为空
// 例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
// （注意：这两个序列的长度是相等的）

function IsPopOrder(pushV, popV) {
    let stack = [],k = 0;
    for(let i = 0;i < pushV.length;i++){
        stack.unshift(pushV[i]);
        while(stack[0] && popV[k] && stack[0] === popV[k]){
            stack.shift();
            k++;
        }
    }
    return stack.length === 0;
}
```

### dp

#### 股票题状态机

本文就来告诉你这个框架，然后带着你一道一道秒杀。

这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。

第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。

##### 一、穷举框架

首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。

递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。

而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。

```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

比如说这个问题，**每天都有三种「选择」**：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。

很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。**这个问题的「状态」有三个**，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

```
dp[i][k][0 or 1]
0 <= i <= n-1, 1 <= k <= K
n 为天数，大 K 为最多交易数
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

而且我们可以用自然语言描述出每一个状态的含义，比如说 `dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 `dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

##### 二、状态转移框架

现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。

![40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png](https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png)

通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
```

这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。**如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了**。不过还差最后一点点，就是定义 base case，即最简单的情况。

#### 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

```js
var maxProfit = function(prices) {
    let dp_i_0 = 0,dp_i_1 = -Infinity;
    for(let i = 0;i < prices.length;i++){
        dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]);
        dp_i_1 = Math.max(dp_i_1,-prices[i]);
    }
    return dp_i_0;
};
```

#### 买卖股票的最佳时机 II

```js
1. 只要股票价格上涨，上涨的部分就是我的利润，可以理解为上涨期间第一天买入，然后一直持有到上涨最后一天即下跌前一天再卖出
2. 只要股票价格下跌，那我肯定在下跌前一天卖了，而且下跌期间永远不会买入
var maxProfit = function(prices) {
  let profit = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    if (prices[i + 1] > prices[i]) profit += prices[i + 1] - prices[i];
  }
  return profit;
};
```

#### 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39（熟悉）

```javascript
1.dp[0] = 0,dp[1] = dp[2] = 1
2.dp[i] = dp[i-1] + dp[i-2]
function Fibonacci(n)
{
    // write code here
    let arr = [0,1];
    for(let i = 2;i <= n;i++){
        arr[i] = arr[i-1] + arr[i-2];
    }
    return arr[n];
}
```

#### 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。（熟悉）
```javascript
dp(i) = dp(i-1) + dp(i-2)
function jumpFloor(n)
{
    // write code here
    let arr = [0,1,2];
    for(let i = 2;i <= n;i++){
        arr[i] = arr[i-1] + arr[i-2];
    }
    return arr[n];
}
```

####  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。（熟悉）
```javascript
 dp(i) = dp(i-1) * 2
function jumpFloorII(number)
{
    let arr = [0,1,2];
    for(let i = 3;i <= number;i++){
        arr[i] = arr[i-1] * 2;
    }
    return arr[number];
}
```

#### 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？（熟悉）
```javascript
1.dp[0] = 0,dp[1] = 1,dp[2] = 2
2.dp[i] = dp[i-1] + dp[i-2]
function rectCover(number)
{
    //1 2 3 5
    let arr = [0,1,2];
    for(let i = 3;i <= number;i++){
        arr[i] = arr[i-1] + arr[i-2];
    }
    return arr[number];
}
```

#### 最大子序和
```javascript
dp[i] += max(dp[i-1],0)
// 给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
function FindGreatestSumOfSubArray(array)
{
    let max = array[0];
    for(let i = 1;i < array.length;i++){
        array[i] += Math.max(0,array[i-1]);
        max = Math.max(max,array[i]);
    }
    return max;
}
```

#### 打家劫舍（熟悉）

```js
var rob = function(nums) {
    if(nums.length === 0) return 0;
    if(nums.length === 1) return nums[0];
    if(nums.length === 2) return Math.max(nums[0],nums[1]);
    if(nums.length === 3) return Math.max(nums[0] + nums[2],nums[1]);
    let dp = [nums[0],nums[1],Math.max(nums[0] + nums[2],nums[1])];
    for(let i = 3;i < nums.length;i++){
        dp[i] = nums[i] + Math.max(dp[i-2],dp[i-3]);
    }
    return Math.max(dp[nums.length-1],dp[nums.length-2]);
};
```

#### 完全平方数

```js
//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
var numSquares = function(n) {
    const dp = [...Array(n+1)].map(_=>0); // 数组长度为n+1，值均为0
    for (let i = 1; i <= n; i++) {
        dp[i] = i; // 最坏的情况就是每次+1
        for (let j = 1; i - j * j >= 0; j++) { 
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程
        }
    }
    return dp[n];
};
```

#### 把只包含质因子2、3和5的数称作丑数（Ugly Number）。（熟悉）

```javascript
//例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
1. 0-6都是丑数，返回其值即可
2. 使用t1-t3表示2，3，5公因子的个数，每次取最小的公因子值，初值为1
function GetUglyNumber_Solution(index)
{
    if(index < 7) return index;
    let res = [1];
    let t2 = 0,t3 = 0,t5 = 0;
    for(let i = 1;i < index;i++){
        res[i] = Math.min(res[t2]*2,res[t3]*3,res[t5]*5);
        res[i] === res[t2]*2 && t2++;
        res[i] === res[t3]*3 && t3++;
        res[i] === res[t5]*5 && t5++;
    }
    return res[index-1]
}
```

#### 回文子串

```js
var countSubstrings = function(s) {
    let s2 = s.split('').reverse().join('');
    let sum = 0;
    const len = s.length;
    for (let i = 0; i < len; i++) {
        for (let j = i + 1; j <= len; j++) {
            if (s.substr(i, j - i) === s2.substr(len - j, j - i)) {
                sum += 1
            }
        }
    }
    return sum;
};
```

#### 最长回文子串

```js
//暴力求出子集，过滤排序
var longestPalindrome = function(s) {
    function isStr(str){
        return str.length ? str === str.split('').reverse().join('') : false;
    }
    var subsets = function(str) {
        let res = [];
        for(let i = 0;i < str.length;i++){
            for(let j = i+1;j <= str.length;j++){
                res.push(str.substr(i,j-i));
            }
        }
        return res;
    };
    if(!s.length) return '';
    let ans = subsets(s);
    ans = ans.filter(x => isStr(x)).sort((x,y) => y.length-x.length);
    return ans[0];
};
```

#### 无重复字符的最长子串

```js
1. 维护一个子串存储当前子串
2. 如果子串中存在当前字符则从截取子串中该字符之后的字符串作为新的子串
3. 注意len = 1,和无重复的情况
var lengthOfLongestSubstring = function(s) {
    if(!s.length) return '';
    let sub = '',res = '';
    for(let i = 0;i < s.length;i++){
        if(sub === ''){
            sub += s[i];
            if(i === s.length-1 && res.length < sub.length) res = sub;
        }else{
            if(sub.indexOf(s[i]) === -1){
                sub += s[i];
                if(i === s.length-1 && res.length < sub.length) res = sub;
            }else{
                if(sub.length > res.length) res = sub;
                sub = sub.substr(sub.indexOf(s[i])+1) + s[i];
            }
        }
    }
    return res.length;
};
```

#### 杨辉三角（熟悉）

```javascript
function print(n) {
    let arr = [],n1 = n;
    while(n1--){
        arr.push([]);
    }
    for(let i = 0;i < n;i++){
        for(let j = 0;j <= i;j++){
            if(j === 0 || j === i) arr[i][j] = 1;
            else{
                arr[i][j] = arr[i-1][j-1]+arr[i-1][j];
            }
        }
    }
    arr.forEach(x => console.log(x.toString().replace(/,/g,' ')));
}
```

### 位运算

#### 括号生成

```js
//给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合
dfs
var generateParenthesis = function(n) {
    if(!n) return [];
    let res = [];
    function dfs(subs,left,right,n){
        //左右括号都用完
        if(left === n && right === n){
            res.push(subs);
            return;
        }
        //栈中的右括号不能多于左括号
        if(left < right){
            return;
        }
        //递归遍历
        left < n && dfs(subs+'(',left+1,right,n);
        right < n && dfs(subs+')',left,right+1,n);
    }
    dfs('',0,0,n);
    return res;
};
```

#### 回溯算法板子

```js
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

for 选择 in 选择列表:
    做选择
    backtrack(路径, 选择列表)
    撤销选择
```

#### 给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的数字可以无限制重复被选取。

```js
var combinationSum = function(candidates, target) {
    if(!candidates.length) return [];
    let res = [],len = candidates.length;
    candidates.sort((x,y) => x-y);
    function dfs(index,tar,path){
        if(tar === 0){
            res.push(path);
            return;
        }
        for(let i = index;i < len;i++){
            //剪枝关键
            if(tar < candidates[i]) break;
            path.push(candidates[i]);
            dfs(i,tar - candidates[i],path.slice(0));
            path.pop();
        }
    }
    dfs(0,target,[]);
    return res;
};
```

#### 全排列

```js
var permute = function(nums) {
    let len = nums.length;
    let ans = [];
    function dfs(res){
        if(res.length === len){
            ans.push(res);
            return;
        }
        for(let i = 0;i < len;i++){
            if(res.indexOf(nums[i]) === -1){
                //核心回溯思维
                res.push(nums[i]);
                dfs(res.slice(0));
                res.pop();
            }
        }
    }
    dfs([]);
    return ans;
};
```

#### 求子集

```js
1. 一个集合的右2^n个子集
2. 使用二进制模拟，每位为取或不取
3. 举个例子：[1,2,3]  => 符号位： 001  010  100  => 0-7与之&
    => [] [001] [010] [001,010] [100] [001,100] [010,100] [001,010,100] 刚好八种，并且对应数组下标。

var subsets = function(nums) {
    let n = 1 << nums.length;
    let res = [];
    for(let i = 0;i < n;i++){
        let temp = [];
        for(let j = 0;j < nums.length;j++){
            if(i & (1 << j)){
                temp.push(nums[j]);
            }
        }
        res.push(temp);
    }
    return res;
};
```

#### 给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

```js
1. 奇数1的个数等于前一个偶数＋1
2. 偶数1的个数等于当前偶数 >> 1 的值
6 和 3  110 011 num(110) = num(110 >> 1)
2 和 3  010 011 num(011) = num(010) + 1
var countBits = function(num) {
    let res = [0];
    for(let i = 1;i <= num;i++){
        if(i & 1){
            res[i] = res[i-1] + 1;
        }else{
            res[i] = res[i >> 1];
        }
    }
    return res;
};
```

#### 汉明距离（熟悉）

```js
//二进制中同位不同值置为1，否则取0
var hammingDistance = function(x, y) {
    let ans = x ^ y,count = 0;
    while(ans){
        if(ans & 1) count++;
        ans = ans >> 1;
    }
    return count;
};
```

#### 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
```javascript
n & (n-1)每次1的数量--
function NumberOf1(n)
{
    let count = 0;
    while(n){
        count++;
        n = n & (n-1);
    }
    return count;
}
```

#### 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```javascript
function Sum_Solution(n)
{
    // write code here
    return (n ** 2 + n) >> 1;
}
```

#### 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
```javascript
1. ^ 不进位的加法
2. & 判断进位点
3. << 1 进位
function Add(num1, num2)
{
    return num2 ? Add(num1 ^ num2,(num1 & num2) << 1) : num1;
}
```
#### 不要加减乘除实现一个数为原理的七倍数
```javascript
1. << 3 扩大8倍
2. 计算补码 -1
3. 两者相加
function multiplySeven(n){
    return Add(n << 3,Add(~n,1))
}
```


### 排序算法

#### 冒泡
```javascript
function bubbleSort(arr){
    for(let i = arr.length-1;i > 1;i--){
        for(let j = 0;j < i;j++){
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
            }
        }
    }
    return arr;
}
```
#### 选择
```javascript
function selectSort(arr){
    for(let i = 0;i < arr.length-1;i++){
        for(let j = i + 1;j < arr.length;j++){
            if(arr[j] < arr[i]){
                [arr[i],arr[j]] = [arr[j],arr[i]];
            }
        }
    }
    return arr;
}
```
#### 插入
```javascript
function insertSort(arr){
    for(let i = 1;i < arr.length;i++){
        for(let j = i;j > 0;j--){
            if(arr[j] < arr[j-1]){
                [arr[j-1],arr[j]] = [arr[j],arr[j-1]];
            }
        }
    }
    return arr;
}
```
#### 快排
```javascript
function quickSort(arr){
    if(arr.length <= 1) return arr;
    let right = [],left = [],keys = arr.shift();
    for(let value of arr){
        if(value > keys){
            right.push(value)
        }else{
            left.push(value);
        }
    }
    return quickSort(left).concat(keys,quickSort(right));
}

```
#### 希尔
```javascript
function shellSort(arr,n){
    for(let i = 1;i < n;i++){
        for(let j = n + i;j < arr.length;j++){
            for(let k = j+1;k > 0;k--){
                if(arr[k] < arr[k-1]){
                    [arr[k-1],arr[k]] = [arr[k],arr[k-1]];
                }
            }
        }
    }
    return arr;
}
```

#### 归并

```javascript
function MergeSort(arr,left,right){
    if(left >= right) return;
    let mid = Math.floor((right - left) >> 1) + left;
    MergeSort(arr,left,mid);
    MergeSort(arr,mid+1,right);
    Merge(arr,left,mid,right);
    return arr;
}
function Merge(arr,left,mid,right){
    let temp = [],i = 0;
    let p1 = left,p2 = mid + 1;
    while(p1 <= mid && p2 <= right){
        arr[p1] <= arr[p2] ? temp[i++] = arr[p1++] : temp[i++] = arr[p2++];
    }
    while(p1 <= mid){
        temp[i++] = arr[p1++];
    }
    while(p2 <= right){
        temp[i++] = arr[p2++];
    }
    for(let i = 0;i < temp.length;i++){
        arr[i+left] = temp[i];
    }
}
```

### 二叉排序树

```javascript
function BST(){
    this.root = null;
    this.insert = insert;
}

function Node(data,left,right){
    this.data = data;
    this.left = left;
    this.right = right;
}

function insert(data){
    let node = new Node(data,null,null);
    if(this.root === null){
        this.root = node;
    }else{
        let current = this.root;
        while(1){
            if(data < current.data){
                if(current.left === null){
                    current.left = node;
                    break;
                }
                current = current.left;
            }else{
                if(current.right === null){
                    current.right = node;
                    break;
                }
                current = current.right;
            }
        }
    }
}

```

### 非递归遍历二叉树
```javascript
//前序
//用栈进行模拟
//每次将栈顶元素添加到结果中，然后将栈顶元素的左右非空子树入栈（注意右子树先入栈，后弹出）
//直到栈为空跳出循环
function pre(root){
    if(root === null) return root;
    let res = [],stack = [];
    stack.push(root);
    while (stack.length){
        let node = stack.pop();
        res.push(node.val);
        node.right && stack.push(node.right);
        node.left && stack.push(node.left);
    }
    return res;
}

//中序
//对栈顶元素深度遍历左子树入栈，然后将栈顶添加到结果中，然后访问当前子节点的右子树，依次循环
function mid(root){
    if(root === null) return root;
    let res = [],stack = [];
    stack.push(root);
    while (stack.length){
        while(root !== null){
            stack.push(root);
            root = root.left;
        }
        let node = stack.pop()
        res.push(node.val);
        root = node.right;
    }
    //根节点添加了两次
    return res.slice(0,res.length-1);
}

//后序
//与前序相似，但生成顺序为根右左，最后将res反序
function next(root){
    if(root === null) return root;
    let res = [],stack = [];
    stack.push(root);
    while (stack.length){
        let node = stack.pop();
        res.push(node.val);
        node.left && stack.push(node.left);
        node.right && stack.push(node.right);
    }
    return res.reverse();
}

//广度优先
function wideTraversal(node) {  
    var nodes = [];  
    if (node != null) {  
        var queue = [];  
        queue.unshift(node);  
        while (queue.length != 0) {  
            var item = queue.shift();  
            nodes.push(item);  
            var children = item.children;  
            for (var i = 0; i < children.length; i++)  
                queue.push(children[i]);  
        }  
    }  
    return nodes;  
}

//深度优先,类似于前序遍历
function deepTraversal(node,nodeList) {  
    if (node) {    
            nodeList.push(node);    
            var children = node.children;    
            for (var i = 0; i < children.length; i++) 
      //每次递归的时候将  需要遍历的节点  和 节点所存储的数组传下去
                deepTraversal(children[i],nodeList);    
        }    
    return nodeList;  
}  
```

